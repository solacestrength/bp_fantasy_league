<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Metrics | British Classic Fantasy League 2025 ðŸ‡¬ðŸ‡§</title>

  <!-- Libraries -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcodejs/qrcode.min.js"></script>
  <link rel="stylesheet" href="assets/css/fix-dropdown.css" />

  <style>
/* === GLOBAL THEME === */
body {
  background: #0b0b0b;
  color: #f1f1f1;
  font-family: 'Inter', sans-serif;
  overflow-x: hidden;
}

/* === SELECT ELEMENTS === */
select {
  background: #2f2f2f;
  border: 1px solid #555;
  color: #f1f1f1;
  padding: 0.35rem 0.5rem;
  border-radius: 0.375rem;
  width: auto;
  min-width: 0;
  display: inline-block;
}

#womenSelect,
#menSelect,
.drill-select {
  background-color: rgba(31, 41, 55, 0.6) !important;
  border: 1px solid #374151;
  color: #f1f1f1;
}

.drill-select {
  display: inline-block;
  font-size: 0.75rem;
  padding-top: 0.4rem;
  padding-bottom: 0.4rem;
  max-width: 70%;
  white-space: nowrap;
  text-overflow: ellipsis;
  overflow: hidden;
}

/* === METRICS LAYOUT === */
.chart-container {
  position: relative;
  width: 100%;
  height: 336px; /* default mobile/tablet height */
  max-width: 600px;
  margin: 0 auto;
  display: block;
  transition: opacity 0.25s ease;
}

@media (min-width: 1024px) {
  .chart-container {
    height: 375px; /* desktop height */
  }
}

/* Canvas fills container exactly (no CSS scaling) */
.chart-container > canvas {
  width: 100% !important;
  height: 100% !important;
  display: block;
  margin-left: auto;
  margin-right: auto;
  object-fit: contain;
}

/* === COLLAPSIBLE SECTIONS === */
.collapsible-content {
  max-height: 0;
  overflow: hidden;
  opacity: 0;
  transition: max-height .5s ease, opacity .4s ease;
}

.collapsible-content.open {
  opacity: 1;
  max-height: 1000px;
  padding-bottom: 1rem;
}

@media (max-width: 1023px) {
  .collapsible-content,
  .collapsible-content.open {
    width: 100%;
    margin-left: 0;
    padding-left: 0;
    padding-right: 0;
  }
}

.arrow {
  transition: transform .4s ease;
}

.arrow.rotate {
  transform: rotate(180deg);
}

/* === SHARE BUTTONS === */
.share-btn {
  background-color: #dc2626;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: .5rem;
  height: 36px;
  width: 36px;
  transition: background-color .2s ease, transform .2s ease;
}

.share-btn:hover {
  background-color: #ef4444;
  transform: translateY(-1px);
}

.share-icon {
  filter: invert(1);
  height: 18px;
  width: 18px;
}

/* --- Adjust histogram share button alignment --- */
.chart-container + .chart-container .share-btn {
  margin-top: 20px; /* small offset so it sits just below donut legend */
}

@media (min-width: 1024px) {
  .chart-container + .chart-container .share-btn {
    margin-top: 24px; /* slightly more breathing room on desktop */
  }
}

/* === BACK PILL (Drilldown) === */
.back-pill {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 0.35rem;
  padding: 0.5rem 1.1rem;
  border-radius: 999px;
  background-color: #111827;
  border: 1px solid #374151;
  color: #e5e7eb;
  font-size: 0.7rem;
  font-weight: 500;
  backdrop-filter: blur(6px);
  box-shadow: 0 10px 25px rgba(0,0,0,0.35);
  transition: all .2s ease;
}

.back-pill:hover {
  background-color: #374151;
  color: #f97316;
  transform: translateY(-1px);
}

/* === ANIMATIONS === */
@keyframes fadeInUp {
  0% { opacity: 0; transform: translateY(10px); }
  100% { opacity: 1; transform: translateY(0); }
}

.animate-fade-in-up { animation: fadeInUp 0.8s ease-out forwards; }
.animate-fade-in { animation: fadeInUp 1s ease-out forwards; }

/* === UTILITY (transform stripper marker) === */
.no-transform {
  transform: none !important;
}
</style>
</head>

<body class="relative bg-gray-900 text-white font-sans min-h-screen flex flex-col">
  <div class="absolute inset-0 bg-[url('bc25_logo.jpg')] bg-cover bg-center opacity-45"></div>
  <div class="absolute inset-0 bg-black/70"></div>

  <div class="relative z-10 flex flex-col flex-grow animate-fade-in">
    <!-- HEADER -->
    <header class="site-header w-full bg-gray-900/90 backdrop-blur-sm border-b border-gray-800 relative z-50">
      <div class="w-full flex items-center justify-center px-4 py-3">
        <div class="flex-1 text-center">
          <a href="index.html"
             class="font-bold text-white hover:text-red-500 transition text-sm sm:text-lg md:text-xl lg:text-2xl">
            British Classic Fantasy League 2025 ðŸ‡¬ðŸ‡§
          </a>
        </div>
        <div class="absolute right-4 top-1/2 -translate-y-1/2">
          <button id="menu-btn" aria-expanded="false"
                  class="text-gray-300 p-2 rounded-md hover:bg-gray-800/50">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-7 w-7" fill="none"
                 viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M4 6h16M4 12h16M4 18h16"/>
            </svg>
          </button>
        </div>
      </div>
    </header>

    <!-- MOBILE MENU -->
    <div id="mobile-menu"
         class="fixed top-16 right-4 w-48 bg-gray-900/95 backdrop-blur-sm border border-gray-800 rounded-md
                shadow-lg z-50 scale-y-0 opacity-0 origin-top transition-transform duration-300 ease-in-out
                pointer-events-none">
      <nav class="flex flex-col py-2 text-white">
        <a href="index.html" class="px-4 py-2 hover:text-red-500 hover:bg-gray-800 transition">Home</a>
        <a href="entry.html" class="px-4 py-2 hover:text-red-500 hover:bg-gray-800 transition">League Entry</a>
        <a href="leaderboard.html" class="px-4 py-2 hover:text-red-500 hover:bg-gray-800 transition">Leaderboard</a>
        <a href="accuracy_scores.html" class="px-4 py-2 hover:text-red-500 hover:bg-gray-800 transition">Accuracy Scores</a>
        <a href="metrics.html" class="px-4 py-2 hover:text-red-500 hover:bg-gray-800 transition">Metrics</a>
      </nav>
    </div>

    <!-- MAIN -->
    <main class="max-w-5xl mx-auto p-6 space-y-8 mt-6 animate-fade-in-up">
      <section class="text-center">
        <h2 class="text-xl font-semibold mb-1">Metrics Dashboard</h2>
        <p class="text-gray-400 text-sm">
          Explore the predicted winner and total distributiond by weight class.<br />
          Double tap/click doughnut segments for a view of points distributions by athlete.<br />
          User note - labels that appear from tapping chart elements will also be visible in your shared images. For visible labels on desktop exports, move cursor outside collapsible section from chart element, then click share button within five seconds ðŸ“Š
        </p>
      </section>

      <!-- WOMEN -->
      <div class="bg-gray-800/60 border border-gray-700 backdrop-blur-sm shadow-lg rounded-2xl p-4">
        <button onclick="toggleSection('women')"
                class="flex items-center justify-between w-full text-left text-lg font-bold">
          <span>Women</span>
          <svg id="arrow-women" xmlns="http://www.w3.org/2000/svg"
               class="h-5 w-5 arrow" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                  d="M19 9l-7 7-7-7"/>
          </svg>
        </button>
        <div id="women" class="collapsible-content mt-4">
          <select id="womenSelect" class="p-2 rounded mb-4 text-sm"></select>

          <!-- WOMEN DONUT -->
          <div class="chart-container" id="womenDonutContainer">
            <div class="flex justify-end mb-1">
              <button class="share-btn" onclick="shareChart('womenDonut','F')">
                <img src="https://img.icons8.com/?size=100&id=qWomDF3YJPZv&format=png&color=000000"
                     class="share-icon" alt="Share"/>
              </button>
            </div>
            <canvas id="womenDonut"></canvas>
          </div>

          <!-- WOMEN DRILLDOWN -->
          <div class="chart-container mt-4" id="womenDrillWrapper" style="display:none; opacity:0;">
            <div class="flex items-center justify-between mb-2 gap-3">
              <select id="womenDrillSelect" class="drill-select"></select>
              <button class="share-btn" onclick="shareDrilldown('F')">
                <img src="https://img.icons8.com/?size=100&id=qWomDF3YJPZv&format=png&color=000000"
                     class="share-icon" alt="Share Drilldown"/>
              </button>
            </div>
            <div class="mb-2">
              <button type="button" class="back-pill" onclick="closeDrilldown('F')">
                <span>&larr;</span>
                <span>Back to Doughnut</span>
              </button>
            </div>
            <canvas id="womenDrill"></canvas>
          </div>

          <!-- WOMEN HISTOGRAM -->
          <div class="chart-container mt-6">
            <div class="flex justify-end mb-1">
              <button class="share-btn" onclick="shareChart('womenHist','F')">
                <img src="https://img.icons8.com/?size=100&id=qWomDF3YJPZv&format=png&color=000000"
                     class="share-icon" alt="Share"/>
              </button>
            </div>
            <canvas id="womenHist"></canvas>
          </div>
        </div>
      </div>

      <!-- MEN -->
      <div class="bg-gray-800/60 border border-gray-700 backdrop-blur-sm shadow-lg rounded-2xl p-4">
        <button onclick="toggleSection('men')"
                class="flex items-center justify-between w-full text-left text-lg font-bold">
          <span>Men</span>
          <svg id="arrow-men" xmlns="http://www.w3.org/2000/svg"
               class="h-5 w-5 arrow" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                  d="M19 9l-7 7-7-7"/>
          </svg>
        </button>
        <div id="men" class="collapsible-content mt-4">
          <select id="menSelect" class="p-2 rounded mb-4 text-sm"></select>

          <!-- MEN DONUT -->
          <div class="chart-container" id="menDonutContainer">
            <div class="flex justify-end mb-1">
              <button class="share-btn" onclick="shareChart('menDonut','M')">
                <img src="https://img.icons8.com/?size=100&id=qWomDF3YJPZv&format=png&color=000000"
                     class="share-icon" alt="Share"/>
              </button>
            </div>
            <canvas id="menDonut"></canvas>
          </div>

          <!-- MEN DRILLDOWN -->
          <div class="chart-container mt-4" id="menDrillWrapper" style="display:none; opacity:0;">
            <div class="flex items-center justify-between mb-2 gap-3">
              <select id="menDrillSelect" class="drill-select"></select>
              <button class="share-btn" onclick="shareDrilldown('M')">
                <img src="https://img.icons8.com/?size=100&id=qWomDF3YJPZv&format=png&color=000000"
                     class="share-icon" alt="Share Drilldown"/>
              </button>
            </div>
            <div class="mb-2">
              <button type="button" class="back-pill" onclick="closeDrilldown('M')">
                <span>&larr;</span>
                <span>Back to Doughnut</span>
              </button>
            </div>
            <canvas id="menDrill"></canvas>
          </div>

          <!-- MEN HISTOGRAM -->
          <div class="chart-container mt-6">
            <div class="flex justify-end mb-1">
              <button class="share-btn" onclick="shareChart('menHist','M')">
                <img src="https://img.icons8.com/?size=100&id=qWomDF3YJPZv&format=png&color=000000"
                     class="share-icon" alt="Share"/>
              </button>
            </div>
            <canvas id="menHist"></canvas>
          </div>
        </div>
      </div>
    </main>

    <!-- VIEW LEADERBOARD BUTTON -->
    <div class="flex justify-center mt-8">
      <a href="leaderboard.html"
         class="inline-flex items-center justify-center bg-gray-800/60 border border-gray-700
                text-gray-200 font-semibold px-6 py-3 rounded-full backdrop-blur-sm shadow-lg
                hover:bg-gray-700/70 hover:text-red-400 transition text-sm">
        View Leaderboard
      </a>
    </div>

    <!-- BACK TO TOP BUTTON -->
    <div class="flex justify-center mt-8">
      <button id="bottomBackToTop"
              class="bg-gray-800/60 border border-gray-700 text-red-500 w-10 h-10 rounded-full
                     flex items-center justify-center backdrop-blur-sm shadow-lg
                     hover:bg-gray-700/70 hover:text-red-400 transition">
        <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="none"
             viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
          <path stroke-linecap="round" stroke-linejoin="round" d="M5 15l7-7 7 7" />
        </svg>
      </button>
    </div>

    <footer class="text-center text-gray-500 text-sm py-4 bg-transparent">
      Sponsored by the Sabado Sessions Podcast
    </footer>
  </div>

<script>
/* ========= PLUGIN: CENTER HISTOGRAM / DRILL AREA ========= */
const centerHistAreaPlugin = {
  id: 'centerHistArea',
  afterLayout(chart, args, opts) {
    if (!opts || !opts.enabled) return;
    if (chart.config.type !== 'bar') return;
    if (!chart.canvas || !/(Hist|Drill)$/i.test(chart.canvas.id)) return;
    if (chart.$histCentered) return;

    const area = chart.chartArea;
    if (!area) return;

    const canvasMid = chart.width / 2;
    const areaMid = (area.left + area.right) / 2;
    const diff = areaMid - canvasMid;
    if (Math.abs(diff) < 1) {
      chart.$histCentered = true;
      return;
    }

    const layout = chart.options.layout || {};
    const padding = layout.padding || {};
    const baseTop = +padding.top || 0;
    const baseLeft = +padding.left || 0;
    const baseBottom = +padding.bottom || 0;
    const baseRight = +padding.right || 0;

    let extraRight = 2 * diff;
    let newRight = baseRight + extraRight;
    if (newRight < 0) newRight = 0;

    chart.options.layout = {
      ...layout,
      padding: {
        top: baseTop,
        left: baseLeft,
        bottom: baseBottom,
        right: newRight
      }
    };

    chart.$histCentered = true;
    chart.update('none');
  }
};

Chart.register(ChartDataLabels, centerHistAreaPlugin);

/* ========= DATA / LAYOUT HELPERS ========= */

const SHEET_URL =
  'https://docs.google.com/spreadsheets/d/e/2PACX-1vSuA8YB98ghNeM-cS6Fs1pJNkEBOI0x7WKI4R0vtvAG68mo7PJZYVj2HsdxH3DDqvieaTpe9zUzJcNW/pub?gid=1506853737&single=true&output=csv';

let allData = [];
const charts = {};

function sizing() {
  const d = window.matchMedia('(min-width:1024px)').matches;
  return {
    donutTitle:   d ? 22 : 14,
    donutSubtitle:d ? 18 : 12,
    donutLegend:  d ? 18 : 12,
    donutPercent: d ? 16 : 12,
    histTitle:    d ? 22 : 14,
    histSubtitle: d ? 18 : 12,
    axisTitle:    d ? 18 : 12,
    axisTick:     d ? 14 : 11,
    histBarLabel: d ? 12 : 10,
    exportWidth:  d ? 1024 : 780,
    qrSize:       d ? 96 : 72,
    creditFont:   d ? 18 : 13,
    headerFont:   d ? 32 : 20,
    subFont:      d ? 26 : 16
  };
}

/* ========= MENU ========= */
const menuBtn = document.getElementById('menu-btn');
const mobileMenu = document.getElementById('mobile-menu');
let menuVisible = false;

function toggleMenu(show) {
  if (show) {
    mobileMenu.classList.remove('scale-y-0','opacity-0','pointer-events-none');
    mobileMenu.classList.add('scale-y-100','opacity-100');
  } else {
    mobileMenu.classList.add('scale-y-0','opacity-0','pointer-events-none');
    mobileMenu.classList.remove('scale-y-100','opacity-100');
  }
}
toggleMenu(false);

if (menuBtn) {
  menuBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    menuVisible = !menuVisible;
    toggleMenu(menuVisible);
  });
}
document.addEventListener('click', (e) => {
  if (!mobileMenu.contains(e.target) && !menuBtn.contains(e.target) && menuVisible) {
    menuVisible = false;
    toggleMenu(false);
  }
});

/* ========= LOAD CSV ========= */
Papa.parse(SHEET_URL, {
  download: true,
  header: true,
  complete: (r) => {
    allData = r.data;
    setupDropdowns();
  }
});

/* ========= DRILLDOWN STATE ========= */
const drillState = {
  F: {
    wrapper: document.getElementById('womenDrillWrapper'),
    select: document.getElementById('womenDrillSelect'),
    canvas: document.getElementById('womenDrill'),
    chart: null,
    currentAthlete: null,
    currentClass: null,
    athleteMap: {},
    totalVotesInClass: 0
  },
  M: {
    wrapper: document.getElementById('menDrillWrapper'),
    select: document.getElementById('menDrillSelect'),
    canvas: document.getElementById('menDrill'),
    chart: null,
    currentAthlete: null,
    currentClass: null,
    athleteMap: {},
    totalVotesInClass: 0
  }
};

/* ========= BLUE GRADIENT FOR HISTOGRAM ========= */
/* Start from a mid blue for a smoother transition into dark blue */
function getBlueGradientColors(n) {
  const colors = [];
  const start = { r: 96, g: 165, b: 250 }; // mid blue
  const end   = { r: 30, g: 64,  b: 175 }; // dark blue
  if (n <= 1) {
    colors.push(`rgb(${start.r},${start.g},${start.b})`);
    return colors;
  }
  for (let i = 0; i < n; i++) {
    const t = i / (n - 1);
    const r = Math.round(start.r + (end.r - start.r) * t);
    const g = Math.round(start.g + (end.g - start.g) * t);
    const b = Math.round(start.b + (end.b - start.b) * t);
    colors.push(`rgb(${r},${g},${b})`);
  }
  return colors;
}

/* ========= RED GRADIENT FOR DRILLDOWN ========= */
function getRedGradientColors(n = 16) {
  const colors = [];
  const start = { r: 248, g: 113, b: 113 }; // soft red (#f87171)
  const end   = { r: 185, g:  28, b:  28 }; // deep red (#b91c1c)
  if (n <= 1) {
    colors.push(`rgb(${start.r},${start.g},${start.b})`);
    return colors;
  }
  for (let i = 0; i < n; i++) {
    const t = i / (n - 1);
    const r = Math.round(start.r + (end.r - start.r) * t);
    const g = Math.round(start.g + (end.g - start.g) * t);
    const b = Math.round(start.b + (end.b - start.b) * t);
    colors.push(`rgb(${r},${g},${b})`);
  }
  return colors;
}

/* ========= SETUP DROPDOWNS ========= */
function setupDropdowns() {
  ['F', 'M'].forEach((g) => {
    const d = allData.filter((r) => r.Gender === g);
    const classes = [...new Set(d.map((r) => r.Class))]
      .filter(Boolean)
      .sort((a, b) => parseFloat(a) - parseFloat(b));

    const select = document.getElementById(g === 'F' ? 'womenSelect' : 'menSelect');
    if (!select) return;

    select.innerHTML = classes.map((c) => `<option value="${c}">${c}kg</option>`).join('');
    select.onchange = () => {
      const newClass = select.value;
      renderCharts(g, newClass);

      const state = drillState[g];
      if (state && state.wrapper.style.display === 'block') {
        const rows = allData.filter(r => r.Gender === g && r.Class === newClass);
        const firstAthlete = rows[0]?.Athlete;
        if (firstAthlete) {
          openDrilldown(g, newClass, firstAthlete, rows, { skipFade: true });
        } else {
          closeDrilldown(g);
        }
      }
    };

    if (classes[0]) renderCharts(g, classes[0]);
  });
}

/* ========= FADE HELPERS ========= */
function fadeIn(el) {
  if (!el) return;
  el.style.display = 'block';
  el.style.opacity = 0;
  requestAnimationFrame(() => { el.style.opacity = 1; });
}

function fadeOut(el) {
  if (!el) return;
  el.style.opacity = 0;
  setTimeout(() => { el.style.display = 'none'; }, 250);
}

/* ========= DESKTOP TOOLTIP LINGER (Patched) ========= */
function enableDesktopTooltipLinger(chart, ms = 5000) {
  // Desktop only
  if (/Android|iPhone|iPad|iPod/i.test(navigator.userAgent)) return;
  if (!chart || !chart.canvas) return;

  // 1) Stop Chart.js from auto-clearing tooltips on mouseout
  const evts = chart.options.events || [];
  chart.options.events = evts.filter(e => e !== 'mouseout' && e !== 'mouseleave');

  // Make sure tooltips are enabled
  if (!chart.options.plugins) chart.options.plugins = {};
  if (!chart.options.plugins.tooltip) chart.options.plugins.tooltip = {};
  chart.options.plugins.tooltip.enabled = true;

  const canvas = chart.canvas;
  let lastActive = [];
  let lingerTimer = null;
  let hovering = false;

  function clearLinger() {
    if (lingerTimer) { clearTimeout(lingerTimer); lingerTimer = null; }
    if (!chart || chart._destroyed) return;
    chart.tooltip.setActiveElements([], {x: 0, y: 0});
    chart.update('none');
  }

  // Track last element under cursor
  canvas.addEventListener('mousemove', (e) => {
    hovering = true;
    const pts = chart.getElementsAtEventForMode(e, 'nearest', { intersect: true }, true);
    if (pts && pts.length) {
      lastActive = pts.map(p => ({ datasetIndex: p.datasetIndex, index: p.index }));
    }
    if (lingerTimer) { clearTimeout(lingerTimer); lingerTimer = null; }
  });

  // Freeze when pointer leaves the canvas
  canvas.addEventListener('mouseleave', () => {
    hovering = false;
    if (!lastActive.length) return;

    // Run on next frame so any remaining internal handlers finish first
    requestAnimationFrame(() => {
      if (!chart || chart._destroyed) return;
      chart.tooltip.setActiveElements(lastActive, { x: chart.width / 2, y: chart.height / 2 });
      chart.update('none');

      lingerTimer = setTimeout(() => {
        if (!hovering) clearLinger();
      }, ms);
    });
  });

  // Clear if the chart scrolls off-screen
  window.addEventListener('scroll', () => {
    const r = canvas.getBoundingClientRect();
    const visible = r.bottom > 0 && r.top < window.innerHeight;
    if (!visible) clearLinger();
  });

  // Clear on outside click
  document.addEventListener('click', (e) => {
    if (lingerTimer && !canvas.contains(e.target)) clearLinger();
  });

  // Cancel any lingering state when re-entering the chart
  canvas.addEventListener('mouseenter', () => {
    hovering = true;
    if (lingerTimer) { clearTimeout(lingerTimer); lingerTimer = null; }
    chart.tooltip.setActiveElements([], {x:0, y:0});
    chart.update('none');
  });
}

  /* ========= DESKTOP: STRIP TRANSFORMS AROUND CHARTS ========= */
function stripTransformsForCharts() {
  // Skip mobile/touch devices
  if (/Android|iPhone|iPad|iPod/i.test(navigator.userAgent)) return;

  const ids = ['womenDonut','menDonut','womenHist','menHist','womenDrill','menDrill'];
  ids.forEach(id => {
    const canvas = document.getElementById(id);
    if (!canvas) return;

    // Walk up a few ancestors and nuke transforms that skew pointer math
    let el = canvas.parentElement;
    let hops = 0;
    while (el && el !== document.body && hops < 6) {
      const tf = getComputedStyle(el).transform;
      if (tf && tf !== 'none') {
        el.classList.add('no-transform');
        el.style.transform = 'none';
      }
      el = el.parentElement;
      hops++;
    }
  });
}

// When any fade-in animation finishes, clear transforms again
document.addEventListener('animationend', (e) => {
  if (/Android|iPhone|iPad|iPod/i.test(navigator.userAgent)) return;
  const t = e.target;
  if (!t) return;
  if (t.classList.contains('animate-fade-in') || t.classList.contains('animate-fade-in-up')) {
    t.classList.add('no-transform');
    t.style.transform = 'none';
    requestAnimationFrame(stripTransformsForCharts);
  }
});

/* ========= CHART RENDERING ========= */
function renderCharts(g, w) {
  const s = sizing();
  const donutId = g === 'F' ? 'womenDonut' : 'menDonut';
  const histId  = g === 'F' ? 'womenHist'  : 'menHist';
  const rows = allData.filter(r => r.Gender === g && r.Class === w);
  if (!rows.length) return;

  /* --- DONUT --- */
  const counts = {};
  rows.forEach(r => { counts[r.Athlete] = (counts[r.Athlete] || 0) + 1; });

  const dLabels = Object.keys(counts);
  const dData   = Object.values(counts);
  const total   = dData.reduce((a, b) => a + b, 0);

  const colors = [
    '#ef4444','#f97316','#facc15','#22c55e','#14b8a6',
    '#3b82f6','#8b5cf6','#ec4899','#06b6d4','#84cc16',
    '#d946ef','#fb7185'
  ];

  if (charts[donutId]) charts[donutId].destroy();
  const donutCtx = document.getElementById(donutId).getContext('2d');

  charts[donutId] = new Chart(donutCtx, {
    type: 'doughnut',
    data: {
      labels: dLabels,
      datasets: [{
        data: dData,
        backgroundColor: colors,
        borderColor: '#111',
        borderWidth: 1
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false, // container defines size
      cutout: '57%',
      layout: { padding: 0 },
      events: ['mousemove','mouseout','click','touchstart','touchmove','touchend'],
      interaction: { mode: 'nearest', intersect: true },
      plugins: {
        title: {
          display: true,
          text: 'Share of Votes',
          color: '#ccc',
          font: { weight: 'bold', size: s.donutTitle },
          padding: { bottom: 8 }
        },
        subtitle: {
          display: true,
          text: `Total Votes â€“ ${total}`,
          color: '#aaa',
          font: { size: s.donutSubtitle },
          padding: { top: 2, bottom: 18 }
        },
        legend: {
  position: 'bottom',
  onClick: null,
  onHover: null,
  labels: {
    color: '#ccc',
    boxWidth: 10,
    boxHeight: 10,
    font: { size: s.donutLegend },
    usePointStyle: true,
    pointStyle: 'circle',

    // â˜… NEW â€” MULTI-ROW LEGEND LOGIC â˜…
    generateLabels(chart) {
  const original = Chart.overrides.doughnut.plugins.legend.labels.generateLabels(chart);
  const total = original.length;

  // Leave 1â€“2 names untouched (natural)
  if (total <= 2) return original;

  const arranged = [];

  // ----- ODD NUMBER â†’ need centered first row -----
  if (total % 2 === 1) {
    // Insert a spacer (invisible legend item)
    arranged.push({
      text: '',
      fillStyle: 'rgba(0,0,0,0)',     // invisible
      strokeStyle: 'rgba(0,0,0,0)',
      hidden: true,
      index: null,
      pointStyle: 'circle'
    });

    // Push the first actual name (centered visually)
    arranged.push(original[0]);
  }

  // ----- PAIRS for all remaining items -----
  const start = (total % 2 === 1) ? 1 : 0;
  for (let i = start; i < total; i += 2) {
    arranged.push(original[i]);
    if (original[i + 1]) arranged.push(original[i + 1]);
  }

  return arranged;
}
  }
},
        tooltip: {
          usePointStyle: true,
          boxWidth: 8,
          boxHeight: 8,
          pointStyle: 'circle',
          callbacks: {
            labelPointStyle: () => ({ pointStyle: 'circle', rotation: 0 }),
            label: (ctx) => {
              const dataset = ctx.chart.data.datasets[0];
              const total = dataset.data.reduce((a, b) => a + b, 0);
              const value = ctx.parsed;
              const percentage = ((value / total) * 100).toFixed(1);
              const voteWord = value === 1 ? 'Vote' : 'Votes';
              return `${value} ${voteWord} â€“ ${percentage}%`;
            }
          }
        },
        datalabels: {
          color: '#fff',
          font: (ctx) => {
            const dataset = ctx.chart.data.datasets[0];
            const value = dataset.data[ctx.dataIndex];
            const totalLocal = dataset.data.reduce((a, b) => a + b, 0);
            const percentage = (value / totalLocal) * 100;

            const angle = (percentage / 100) * 360;
            const base = s.donutPercent;
            let size;

            if (angle < 10)       size = base * 0.45;
            else if (angle < 20)  size = base * 0.6;
            else if (angle < 40)  size = base * 0.8;
            else                  size = base;

            return { weight: 'bold', size: Math.max(8, size) };
          },
          formatter: (v, ctx) => {
            const dataset = ctx.chart.data.datasets[0];
            const totalLocal = dataset.data.reduce((a, b) => a + b, 0);
            const p = (v / totalLocal) * 100;
            return p >= 2 ? `${p.toFixed(1)}%` : '';
          },
          display: (ctx) => {
            const dataset = ctx.chart.data.datasets[0];
            const value = dataset.data[ctx.dataIndex];
            const totalLocal = dataset.data.reduce((a, b) => a + b, 0);
            const percentage = (value / totalLocal) * 100;
            return percentage >= 3.5;
          },
          anchor: 'center',
          align: 'center',
          clamp: true,
          clip: true,
          offset: 0
        }
      },
      onClick: (evt, elements) => handleDonutClick(g, w, donutId, evt, elements, rows)
    }
  });

  enableDesktopTooltipLinger(charts[donutId], 5000);

  /* --- HISTOGRAM --- */
  const vals = rows
    .map(r => parseFloat(r.PredictedTotal))
    .filter(v => !isNaN(v) && v > 0);
  if (!vals.length) {
    if (charts[histId]) charts[histId].destroy();
    return;
  }

  const N = vals.length;
  const min = Math.min(...vals);
  const max = Math.max(...vals);
  const bins = Math.max(3, Math.round(Math.sqrt(N)));
  const bw = (max - min) / bins || 1;

  const countsH = Array(bins).fill(0);
  vals.forEach(v => {
    let i = Math.floor((v - min) / bw);
    if (i >= bins) i = bins - 1;
    if (i < 0) i = 0;
    countsH[i]++;
  });

  const labelsH = Array.from({ length: bins }, (_, i) =>
    `${(min + i * bw).toFixed(0)}â€“${(min + (i + 1) * bw).toFixed(0)}`
  );

  const minC = Math.min(...countsH);
  const maxC = Math.max(...countsH);
  const yMin = Math.floor(minC / 2);
  const span = maxC - yMin;
  const step = Math.max(1, Math.round(span / 4));
  const yMax = Math.ceil(maxC / step) * step;

  if (charts[histId]) charts[histId].destroy();
  const histCtx = document.getElementById(histId).getContext('2d');

  charts[histId] = new Chart(histCtx, {
    type: 'bar',
    data: {
      labels: labelsH,
      datasets: [{
        data: countsH,
        backgroundColor: getBlueGradientColors(bins),
        borderRadius: 5,
        barPercentage: 0.9,
        categoryPercentage: 1.0
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      layout: { padding: { bottom: 60 } },
      events: ['mousemove','mouseout','click','touchstart','touchmove','touchend'],
      interaction: { mode: 'nearest', intersect: true },
      plugins: {
        centerHistArea: { enabled: true },
        legend: { display: false },
        datalabels: {
          color: '#fff',
          font: { size: s.histBarLabel, weight: 'normal' },
          formatter: (v) => v > 0 ? v : '',
          anchor: 'center',
          align: 'center',
          clamp: true
        },
        tooltip: {
          usePointStyle: true,
          boxWidth: 8,
          boxHeight: 8,
          pointStyle: 'circle',
          callbacks: {
            labelPointStyle: () => ({ pointStyle: 'circle', rotation: 0 }),
            title: (items) => (items[0]?.label) || '',
            label: (ctx) => `Vote Count - ${ctx.parsed.y}`
          }
        }
      },
      scales: {
        x: {
          offset: true,
          ticks: {
            color: '#ccc',
            font: { size: s.axisTick },
            autoSkip: false,
            maxRotation: 60,
            minRotation: 45,
            callback: (value, index) => labelsH[index] || ''
          },
          title: {
            display: true,
            text: 'Predicted Total (kg)',
            color: '#ccc',
            font: { size: s.axisTitle, weight: 'bold' }
          },
          grid: { display: false }
        },
        y: {
          min: yMin,
          max: yMax,
          beginAtZero: false,
          ticks: {
            color: '#ccc',
            font: { size: s.axisTick }
          },
          title: {
            display: true,
            text: `Vote Count (Total = ${N})`,
            color: '#ccc',
            font: { size: s.axisTitle, weight: 'bold' }
          },
          grid: { display: false }
        }
      }
    }
  });

  charts[histId].$histCentered = false;
  enableDesktopTooltipLinger(charts[histId], 5000);

  // âœ… Final transform cleanup after both donut + hist render
  requestAnimationFrame(stripTransformsForCharts);
}

/* ========= DRILLDOWN CHART ========= */
function renderDrillChart(g, athlete) {
  const state = drillState[g];
  if (!state || !state.athleteMap[athlete]) return;

  const s = sizing();
  const votes = state.athleteMap[athlete].votes || [];
  const colors = getRedGradientColors();

  const counts = Array(16).fill(0);
  votes.forEach(v => {
    if (v >= 1 && v <= 16) counts[v - 1]++;
  });

  if (state.chart) state.chart.destroy();

  const ctx = state.canvas.getContext('2d');
  state.chart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: Array.from({ length: 16 }, (_, i) => i + 1),
      datasets: [{
        data: counts,
        backgroundColor: colors,
        borderRadius: 5,
        barPercentage: 0.9,
        categoryPercentage: 1.0
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      layout: { padding: { bottom: 30 } },
      events: ['mousemove','mouseout','click','touchstart','touchmove','touchend'],
      interaction: { mode: 'nearest', intersect: true },
      plugins: {
        centerHistArea: { enabled: true },
        legend: { display: false },
        datalabels: {
          color: '#fff',
          font: { size: s.histBarLabel, weight: 'normal' },
          formatter: (v) => v > 0 ? v : '',
          anchor: 'center',
          align: 'center',
          clamp: true
        },
        tooltip: {
          usePointStyle: true,
          boxWidth: 8,
          boxHeight: 8,
          pointStyle: 'circle',
          callbacks: {
            labelPointStyle: () => ({ pointStyle: 'circle', rotation: 0 }),
            title: (items) => (items[0]?.label) || '',
            label: (ctx2) => `Vote Count - ${ctx2.parsed.y}`
          }
        },
        title: { display: false }
      },
      scales: {
        x: {
          ticks: {
            color: '#ccc',
            font: { size: s.axisTick },
            maxRotation: 0,
            minRotation: 0
          },
          title: {
            display: true,
            text: 'Points / Confidence Level',
            color: '#ccc',
            font: { size: s.axisTitle, weight: 'bold' }
          },
          grid: { display: false }
        },
        y: {
          beginAtZero: true,
          ticks: {
            color: '#ccc',
            font: { size: s.axisTick },
            precision: 0
          },
          title: {
            display: true,
            text: 'Vote Count',
            color: '#ccc',
            font: { size: s.axisTitle, weight: 'bold' }
          },
          grid: { display: false }
        }
      }
    }
  });

  state.chart.$histCentered = false;
  enableDesktopTooltipLinger(state.chart, 5000);
  requestAnimationFrame(stripTransformsForCharts);
}

/* ========= DRILLDOWN HELPERS ========= */

// double-click donut -> drilldown
function handleDonutClick(g, w, donutId, evt, elements, rows) {
  if (!evt || !evt.native) return;
  const target = evt.native.target;
  const now = Date.now();

  if (!target.__lastClick) {
    target.__lastClick = now;
    return;
  }

  const diff = now - target.__lastClick;
  target.__lastClick = now;

  if (diff < 320 && elements && elements.length > 0) {
    const idx = elements[0].index;
    const chart = charts[donutId];
    if (!chart) return;
    const athlete = chart.data.labels[idx];
    if (!athlete) return;
    openDrilldown(g, w, athlete, rows, { skipFade: false });
  }
}

function buildDrillAthleteMap(rows) {
  const map = {};
  rows.forEach(r => {
    const name = r.Athlete;
    if (!name) return;
    const pts = parseInt(r.Points, 10);
    if (!map[name]) map[name] = { votes: [] };
    if (!isNaN(pts) && pts >= 1 && pts <= 16) map[name].votes.push(pts);
  });
  return map;
}

function openDrilldown(g, w, athlete, rows, opts = {}) {
  const state = drillState[g];
  if (!state) return;

  const donutContainerId = g === 'F' ? 'womenDonutContainer' : 'menDonutContainer';
  const donutContainer = document.getElementById(donutContainerId);

  // build athlete vote map for this class
  state.athleteMap = buildDrillAthleteMap(rows);
  state.currentAthlete = athlete;
  state.currentClass = w;
  state.totalVotesInClass = rows.length;

  // rebuild dropdown for available athletes
  const names = Object.keys(state.athleteMap);
  state.select.innerHTML = '';
  names.forEach(name => {
    const opt = document.createElement('option');
    opt.value = name;
    opt.textContent = name;
    if (name === athlete) opt.selected = true;
    state.select.appendChild(opt);
  });

  // ensure fallback if invalid athlete passed
  if (!state.athleteMap[athlete]) {
    const fallback = names[0];
    if (fallback) state.currentAthlete = fallback;
  }

  // toggle visibility with fade animations
  if (!opts.skipFade) {
    fadeOut(donutContainer);
    fadeIn(state.wrapper);

    // ensure correct pointer math on desktop after fade-in
    if (!/Android|iPhone|iPad|iPod/i.test(navigator.userAgent)) {
      setTimeout(() => requestAnimationFrame(stripTransformsForCharts), 400);
    }
  } else {
    donutContainer.style.display = 'none';
    state.wrapper.style.display = 'block';
    state.wrapper.style.opacity = 1;

    // ensure correct pointer math even when skipping fade
    if (!/Android|iPhone|iPad|iPod/i.test(navigator.userAgent)) {
      requestAnimationFrame(stripTransformsForCharts);
    }
  }

  // render the selected athlete's drilldown chart
  renderDrillChart(g, state.currentAthlete);

  // change event for athlete selector
  state.select.onchange = () => {
    const selAthlete = state.select.value;
    if (!selAthlete) return;
    state.currentAthlete = selAthlete;
    renderDrillChart(g, selAthlete);
  };
}

function closeDrilldown(g) {
  const state = drillState[g];
  if (!state) return;

  const donutContainerId = g === 'F' ? 'womenDonutContainer' : 'menDonutContainer';
  const donutContainer = document.getElementById(donutContainerId);

  fadeOut(state.wrapper);
  fadeIn(donutContainer);

  if (state.chart) {
    state.chart.destroy();
    state.chart = null;
  }

  state.currentAthlete = null;
  state.currentClass = null;
  state.athleteMap = {};
  state.totalVotesInClass = 0;
}

/* ========= COLLAPSIBLE SECTIONS ========= */

function toggleSection(id) {
  const c = document.getElementById(id);
  const a = document.getElementById(`arrow-${id}`);
  const main = document.querySelector('main');
  if (!c || !a || !main) return;

  const open = c.classList.toggle('open');
  a.classList.toggle('rotate', open);

  if (open) {
    const wrapper = c.closest('.bg-gray-800\\/60') || c;
    wrapper.scrollIntoView({ behavior: 'smooth', block: 'start' });
  }

  const anyOpen = document.querySelector('.collapsible-content.open');
  if (anyOpen) main.classList.add('expanded');
  else main.classList.remove('expanded');

  setTimeout(repositionBottomButtons, 600);
}

function repositionBottomButtons() {
  const main = document.querySelector('main');
  const leaderboard = document.querySelector('a[href="leaderboard.html"]')?.closest('div');
  const backToTop = document.getElementById('bottomBackToTop')?.closest('div');
  if (!main || !leaderboard || !backToTop) return;

  const contentHeight = main.scrollHeight;
  const windowHeight = window.innerHeight;
  const offset = Math.max(24, windowHeight - contentHeight / 1.2);

  [leaderboard, backToTop].forEach((el, i) => {
    el.style.transition = 'margin-top 0.6s ease';
    el.style.marginTop = (i === 0 ? offset : 16) + 'px';
  });
}

window.addEventListener('resize', () => {
  repositionBottomButtons();
  Object.values(charts).forEach(chart => {
    if (chart &&
        chart.config.type === 'bar' &&
        chart.canvas &&
        /(Hist|Drill)$/i.test(chart.canvas.id)) {
      chart.$histCentered = false;
      chart.update('none');
    }
  });
});

/* ========= SHARE / EXPORT HELPERS ========= */

function detectBrowserShareSupport() {
  const ua = navigator.userAgent.toLowerCase();
  return {
    isAndroidChrome: ua.includes('android') && ua.includes('chrome') && !ua.includes('edge') && !ua.includes('opr'),
    isChromeIOS: ua.includes('crios')
  };
}

function swapShareButtonFor(containerEl, newBtn) {
  containerEl.innerHTML = '';
  containerEl.appendChild(newBtn);
}

function sanitizeFilename(str) {
  return (str || 'value')
    .toString()
    .normalize('NFKD')
    .replace(/[^\w\-]+/g, '_')
    .replace(/_+/g, '_')
    .replace(/^_+|_+$/g, '')
    .toLowerCase();
}

/* ========= SHARE STANDARD CHARTS ========= */
async function shareChart(id, g) {
  const { isAndroidChrome, isChromeIOS } = detectBrowserShareSupport();
  const s = sizing();
  const src = document.getElementById(id);
  if (!src) return;

  const shareBar = src.previousElementSibling;
  if (!shareBar) return;

  function makeBtn(text) {
    const b = document.createElement('button');
    b.className = "bg-red-600 hover:bg-red-500 text-white rounded-full text-xs font-semibold shadow-md px-3 py-1";
    b.style.minWidth = "140px";
    b.style.height = "24px";
    b.textContent = text;
    return b;
  }

  function resetShareIcon() {
    shareBar.innerHTML =
      '<button class="share-btn" onclick="shareChart(\'' + id + '\', \'' + g + '\')">' +
      '<img src="https://img.icons8.com/?size=100&id=qWomDF3YJPZv&format=png&color=000000" class="share-icon" alt="Share"/>' +
      '</button>';
  }

  const generatingBtn = makeBtn("Generatingâ€¦");
  swapShareButtonFor(shareBar, generatingBtn);
  await new Promise(requestAnimationFrame);

  const sel = document.getElementById(g === 'F' ? 'womenSelect' : 'menSelect');
  const w = sel ? sel.value : '';
  const isDonut = id.includes('Donut');
  const isMobile = window.innerWidth < 768;
  const fn = `metrics_${g}_${w || 'class'}_${isDonut ? 'donut' : 'hist'}.png`;

  // Capture chart as image
  const dataURL = src.toDataURL('image/png');
  const img = new Image();
  img.src = dataURL;
  await img.decode();

  // Build share card
  const card = document.createElement('div');
  card.style.position = 'relative';
  card.style.width = s.exportWidth + 'px';
  card.style.borderRadius = '24px';
  card.style.overflow = 'hidden';
  card.style.margin = '0 auto';
  card.style.backgroundImage = "url('bc25_logo.jpg')";
  card.style.backgroundSize = 'cover';
  card.style.backgroundPosition = 'center';
  card.style.boxShadow = '0 16px 40px rgba(0,0,0,0.55)';

  const overlay = document.createElement('div');
  overlay.style.position = 'absolute';
  overlay.style.inset = '0';
  overlay.style.background = 'rgba(0,0,0,0.70)';
  card.appendChild(overlay);

  const inner = document.createElement('div');
  inner.style.position = 'relative';
  inner.style.textAlign = 'center';
  inner.style.color = '#fff';
  inner.style.fontFamily = "'Inter', sans-serif";
  inner.style.zIndex = '2';
  inner.style.padding = '32px 26px 26px 26px';
  card.appendChild(inner);

  const header = document.createElement('h2');
  header.textContent = 'British Classic Fantasy League 2025 ðŸ‡¬ðŸ‡§';
  header.style.fontSize = (isMobile ? s.headerFont * 1.4 : s.headerFont * 1.2) + 'px';
  header.style.fontWeight = '700';
  header.style.margin = '0 0 6px 0';

  const sub = document.createElement('p');
  const label = (w ? `${w}kg ` : '') + (g === 'F' ? 'Women' : 'Men');
  sub.innerHTML = isDonut
    ? label
    : `${label}<br>Distribution of Predicted Winning Totals`;
  sub.style.fontSize = (isMobile ? s.subFont * 1.5 : s.subFont * 1.5) + 'px';
  sub.style.fontWeight = '600';
  sub.style.color = '#e5e7eb';
  sub.style.margin = '0 0 18px 0';

  img.style.display = 'block';
  img.style.margin = '0 auto 16px auto';
  img.style.borderRadius = '14px';
  // Unified export width so background scale matches donut
  img.style.width = '82%';
  img.style.height = 'auto';

  const credit = document.createElement('p');
  credit.style.fontSize = (isMobile ? s.creditFont * 1.5 : s.creditFont * 1.5) + 'px';
  credit.style.color = '#d1d5db';
  credit.style.lineHeight = '1.5';
  credit.style.marginTop = '8px';
  credit.style.textAlign = 'center';
  credit.innerHTML =
    'Data from tinyurl.com/britishclassicfl-metrics<br><br>Sponsored by the Sabado Sessions Podcast';

  const qr = new Image();
  const qrsz = s.qrSize;
  qr.src = `https://api.qrserver.com/v1/create-qr-code/?size=${qrsz}x${qrsz}&data=${encodeURIComponent('https://solacestrength.github.io/britishclassicfl/metrics.html')}`;
  qr.style.position = 'absolute';
  qr.style.bottom = '18px';
  qr.style.left = '18px';
  qr.style.width = qrsz + 'px';
  qr.style.height = qrsz + 'px';
  qr.style.borderRadius = '6px';

  inner.append(header, sub, img, credit);
  card.appendChild(qr);
  document.body.appendChild(card);

  await new Promise(requestAnimationFrame);
  const canvas = await html2canvas(card, { backgroundColor: null, scale: 2, useCORS: true, scrollY: 0 });
  card.remove();

  const blob = await new Promise(r => canvas.toBlob(r, 'image/png'));
  if (!blob) {
    resetShareIcon();
    return;
  }
  const file = new File([blob], fn, { type: 'image/png' });

  // Android Chrome: show dedicated share button so user gets full native sheet
  if (isAndroidChrome) {
    const shareBtn = makeBtn("Share Generated Image");
    shareBtn.onclick = async () => {
      try {
        if (navigator.canShare && navigator.canShare({ files: [file] })) {
          await navigator.share({
            title: 'British Classic Fantasy League 2025',
            text: 'Check out these stats!',
            files: [file]
          });
        } else {
          const url = URL.createObjectURL(file);
          const a = document.createElement('a');
          a.href = url;
          a.download = fn;
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);
        }
      } catch (e) {
        console.error(e);
      }
      resetShareIcon();
    };
    swapShareButtonFor(shareBar, shareBtn);
    return;
  }

  // Other platforms: try native share; fallback to direct PNG download
  try {
    if (!isChromeIOS && navigator.canShare && navigator.canShare({ files: [file] })) {
      await navigator.share({
        title: 'British Classic Fantasy League 2025',
        text: 'Check out these stats!',
        files: [file]
      });
    } else {
      const url = URL.createObjectURL(file);
      const link = document.createElement('a');
      link.href = url;
      link.download = fn;
      document.body.appendChild(link);
      link.click();
      link.remove();
      URL.revokeObjectURL(url);
    }
  } catch (err) {
    console.error('Share failed:', err);
  }

  resetShareIcon();
}

/* ========= DRILLDOWN SHARE ========= */
async function shareDrilldown(g) {
  const state = drillState[g];
  if (!state || !state.chart || !state.currentAthlete || !state.currentClass) return;

  const { isAndroidChrome, isChromeIOS } = detectBrowserShareSupport();
  const s = sizing();
  const isMobile = window.innerWidth < 768;

  const athlete = state.currentAthlete;
  const votes = state.athleteMap[athlete]?.votes || [];
  const votesForAthlete = votes.length;
  const n = state.totalVotesInClass || votesForAthlete;
  const fn = `metrics_drill_${g}_${sanitizeFilename(state.currentClass)}_${sanitizeFilename(athlete)}.png`;

  const srcCanvas = state.canvas;
  const chartDataUrl = srcCanvas.toDataURL('image/png');
  const chartImg = new Image();
  chartImg.src = chartDataUrl;
  await chartImg.decode();

  const exportWidth = s.exportWidth;
  const card = document.createElement('div');
  card.style.position = 'relative';
  card.style.width = exportWidth + 'px';
  card.style.borderRadius = '24px';
  card.style.overflow = 'hidden';
  card.style.margin = '0 auto';
  card.style.backgroundImage = "url('bc25_logo.jpg')";
  card.style.backgroundSize = 'cover';
  card.style.backgroundPosition = 'center';
  card.style.boxShadow = '0 16px 40px rgba(0,0,0,0.55)';

  const overlay = document.createElement('div');
  overlay.style.position = 'absolute';
  overlay.style.inset = '0';
  overlay.style.background = 'rgba(0,0,0,0.70)';
  card.appendChild(overlay);

  const inner = document.createElement('div');
  inner.style.position = 'relative';
  inner.style.textAlign = 'center';
  inner.style.color = '#fff';
  inner.style.fontFamily = "'Inter', sans-serif";
  inner.style.zIndex = '2';
  inner.style.padding = '32px 26px 26px 26px';
  card.appendChild(inner);

  const header = document.createElement('h2');
  header.textContent = 'British Classic Fantasy League 2025 ðŸ‡¬ðŸ‡§';
  header.style.fontSize = (isMobile ? s.headerFont * 1.4 : s.headerFont * 1.2) + 'px';
  header.style.fontWeight = '700';
  header.style.margin = '0 0 6px 0';

  const sub1 = document.createElement('p');
  sub1.textContent = athlete;
  sub1.style.fontSize = (isMobile ? s.subFont * 1.5 : s.subFont * 1.5) + 'px';
  sub1.style.fontWeight = '600';
  sub1.style.margin = '0 0 4px 0';

  const sub2 = document.createElement('p');
  sub2.textContent = `${votesForAthlete} Votes Out of ${n}`;
  sub2.style.fontSize = (isMobile ? s.creditFont * 1.5 : s.creditFont * 1.5) + 'px';
  sub2.style.color = '#d1d5db';
  sub2.style.margin = '0 0 18px 0';

  chartImg.style.display = 'block';
  chartImg.style.margin = '0 auto 16px auto';
  chartImg.style.borderRadius = '14px';
  chartImg.style.width = '82%';
  chartImg.style.height = 'auto';

  const credit = document.createElement('p');
  credit.style.fontSize = (isMobile ? s.creditFont * 1.5 : s.creditFont * 1.5) + 'px';
  credit.style.color = '#d1d5db';
  credit.style.lineHeight = '1.5';
  credit.style.marginTop = '8px';
  credit.style.textAlign = 'center';
  credit.innerHTML =
    'Data from tinyurl.com/britishclassicfl-metrics<br><br>Sponsored by the Sabado Sessions Podcast';

  const qrSize = s.qrSize;
  const qrWrapper = document.createElement('div');
  qrWrapper.style.position = 'absolute';
  qrWrapper.style.bottom = '18px';
  qrWrapper.style.left = '18px';
  new QRCode(qrWrapper, {
    text: 'https://solacestrength.github.io/britishclassicfl/metrics.html',
    width: qrSize,
    height: qrSize,
    margin: 0
  });

  inner.append(header, sub1, sub2, chartImg, credit);
  card.appendChild(qrWrapper);
  document.body.appendChild(card);

  await new Promise(requestAnimationFrame);
  const canvas = await html2canvas(card, { backgroundColor: null, scale: 2, useCORS: true, scrollY: 0 });
  card.remove();

  const blob = await new Promise(res => canvas.toBlob(res, 'image/png'));
  if (!blob) return;

  const file = new File([blob], fn, { type: 'image/png' });

  try {
    if (!isChromeIOS && navigator.canShare && navigator.canShare({ files: [file] })) {
      await navigator.share({
        title: 'British Classic Fantasy League 2025 â€“ Metrics Drilldown',
        text: 'Check out these stats!',
        files: [file]
      });
    } else {
      const url = URL.createObjectURL(file);
      const a = document.createElement('a');
      a.href = url;
      a.download = fn;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }
  } catch (err) {
    console.error('Share failed; falling back to download.', err);
    const url = URL.createObjectURL(file);
    const a = document.createElement('a');
    a.href = url;
    a.download = fn;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }
}

/* ========= BACK TO TOP ========= */
const bottomBackToTop = document.getElementById('bottomBackToTop');
if (bottomBackToTop) {
  bottomBackToTop.addEventListener('click', () => {
    window.scrollTo({ top: 0, behavior: 'smooth' });
  });
}
</script>
</body>
</html>
